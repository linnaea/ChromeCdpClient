using System;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;
#pragma warning disable 8618,0612
#nullable enable
namespace CdpClient.Cdp;
public sealed partial class InputDomain {
private readonly ConnectedTarget _target;
public InputDomain(ConnectedTarget target) => _target = target;
public sealed partial class DispatchDragEventParams {
/// <summary>
/// Type of the drag event.
/// </summary>
[JsonConverter(typeof(StringEnumConverter))] public enum TypeEnum {
[EnumMember(Value = "dragEnter")] DragEnter,
[EnumMember(Value = "dragOver")] DragOver,
[EnumMember(Value = "drop")] Drop,
[EnumMember(Value = "dragCancel")] DragCancel,
}
[JsonPropertyName("type")]public TypeEnum Type{get;set;}
/// <summary>
/// X coordinate of the event relative to the main frame's viewport in CSS pixels.
/// </summary>
[JsonPropertyName("x")]public double X{get;set;}
/// <summary>
/// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
/// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
/// </summary>
[JsonPropertyName("y")]public double Y{get;set;}
[JsonPropertyName("data")]public Input.DragData Data{get;set;}
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
[JsonPropertyName("modifiers")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Modifiers{get;set;}
}
/// <summary>
/// Dispatches a drag event into the page.
/// </summary>
/// <param name="type">Type of the drag event.</param>
/// <param name="x">X coordinate of the event relative to the main frame's viewport in CSS pixels.</param>
/// <param name="y">Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
/// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.</param>
/// <param name="data"></param>
/// <param name="modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).</param>
[Experimental]public async Task DispatchDragEvent(
 DispatchDragEventParams.TypeEnum @type,double @x,double @y,Input.DragData @data,long? @modifiers=default) {
var resp = await _target.SendRequest("Input.dispatchDragEvent",
new DispatchDragEventParams {
Type=@type,X=@x,Y=@y,Data=@data,Modifiers=@modifiers,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class DispatchKeyEventParams {
/// <summary>
/// Type of the key event.
/// </summary>
[JsonConverter(typeof(StringEnumConverter))] public enum TypeEnum {
[EnumMember(Value = "keyDown")] KeyDown,
[EnumMember(Value = "keyUp")] KeyUp,
[EnumMember(Value = "rawKeyDown")] RawKeyDown,
[EnumMember(Value = "char")] Char,
}
[JsonPropertyName("type")]public TypeEnum Type{get;set;}
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
[JsonPropertyName("modifiers")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Modifiers{get;set;}
/// <summary>
/// Time at which the event occurred.
/// </summary>
[JsonPropertyName("timestamp")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public Input.TimeSinceEpoch? Timestamp{get;set;}
/// <summary>
/// Text as generated by processing a virtual key code with a keyboard layout. Not needed for
/// for `keyUp` and `rawKeyDown` events (default: "")
/// </summary>
[JsonPropertyName("text")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public string? Text{get;set;}
/// <summary>
/// Text that would have been generated by the keyboard if no modifiers were pressed (except for
/// shift). Useful for shortcut (accelerator) key handling (default: "").
/// </summary>
[JsonPropertyName("unmodifiedText")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public string? UnmodifiedText{get;set;}
/// <summary>
/// Unique key identifier (e.g., 'U+0041') (default: "").
/// </summary>
[JsonPropertyName("keyIdentifier")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public string? KeyIdentifier{get;set;}
/// <summary>
/// Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
/// </summary>
[JsonPropertyName("code")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public string? Code{get;set;}
/// <summary>
/// Unique DOM defined string value describing the meaning of the key in the context of active
/// modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
/// </summary>
[JsonPropertyName("key")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public string? Key{get;set;}
/// <summary>
/// Windows virtual key code (default: 0).
/// </summary>
[JsonPropertyName("windowsVirtualKeyCode")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? WindowsVirtualKeyCode{get;set;}
/// <summary>
/// Native virtual key code (default: 0).
/// </summary>
[JsonPropertyName("nativeVirtualKeyCode")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? NativeVirtualKeyCode{get;set;}
/// <summary>
/// Whether the event was generated from auto repeat (default: false).
/// </summary>
[JsonPropertyName("autoRepeat")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public bool? AutoRepeat{get;set;}
/// <summary>
/// Whether the event was generated from the keypad (default: false).
/// </summary>
[JsonPropertyName("isKeypad")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public bool? IsKeypad{get;set;}
/// <summary>
/// Whether the event was a system key event (default: false).
/// </summary>
[JsonPropertyName("isSystemKey")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public bool? IsSystemKey{get;set;}
/// <summary>
/// Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
/// 0).
/// </summary>
[JsonPropertyName("location")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Location{get;set;}
/// <summary>
/// Editing commands to send with the key event (e.g., 'selectAll') (default: []).
/// These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.
/// See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
/// </summary>
[Experimental][JsonPropertyName("commands")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public string[]? Commands{get;set;}
}
/// <summary>
/// Dispatches a key event to the page.
/// </summary>
/// <param name="type">Type of the key event.</param>
/// <param name="modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).</param>
/// <param name="timestamp">Time at which the event occurred.</param>
/// <param name="text">Text as generated by processing a virtual key code with a keyboard layout. Not needed for
/// for `keyUp` and `rawKeyDown` events (default: "")</param>
/// <param name="unmodifiedText">Text that would have been generated by the keyboard if no modifiers were pressed (except for
/// shift). Useful for shortcut (accelerator) key handling (default: "").</param>
/// <param name="keyIdentifier">Unique key identifier (e.g., 'U+0041') (default: "").</param>
/// <param name="code">Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").</param>
/// <param name="key">Unique DOM defined string value describing the meaning of the key in the context of active
/// modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").</param>
/// <param name="windowsVirtualKeyCode">Windows virtual key code (default: 0).</param>
/// <param name="nativeVirtualKeyCode">Native virtual key code (default: 0).</param>
/// <param name="autoRepeat">Whether the event was generated from auto repeat (default: false).</param>
/// <param name="isKeypad">Whether the event was generated from the keypad (default: false).</param>
/// <param name="isSystemKey">Whether the event was a system key event (default: false).</param>
/// <param name="location">Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
/// 0).</param>
/// <param name="commands">EXPERIMENTAL Editing commands to send with the key event (e.g., 'selectAll') (default: []).
/// These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.
/// See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.</param>
public async Task DispatchKeyEvent(
 DispatchKeyEventParams.TypeEnum @type,long? @modifiers=default,Input.TimeSinceEpoch? @timestamp=default,string? @text=default,string? @unmodifiedText=default,string? @keyIdentifier=default,string? @code=default,string? @key=default,long? @windowsVirtualKeyCode=default,long? @nativeVirtualKeyCode=default,bool? @autoRepeat=default,bool? @isKeypad=default,bool? @isSystemKey=default,long? @location=default,string[]? @commands=default) {
var resp = await _target.SendRequest("Input.dispatchKeyEvent",
new DispatchKeyEventParams {
Type=@type,Modifiers=@modifiers,Timestamp=@timestamp,Text=@text,UnmodifiedText=@unmodifiedText,KeyIdentifier=@keyIdentifier,Code=@code,Key=@key,WindowsVirtualKeyCode=@windowsVirtualKeyCode,NativeVirtualKeyCode=@nativeVirtualKeyCode,AutoRepeat=@autoRepeat,IsKeypad=@isKeypad,IsSystemKey=@isSystemKey,Location=@location,Commands=@commands,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class InsertTextParams {
/// <summary>
/// The text to insert.
/// </summary>
[JsonPropertyName("text")]public string Text{get;set;}
}
/// <summary>
/// This method emulates inserting text that doesn't come from a key press,
/// for example an emoji keyboard or an IME.
/// </summary>
/// <param name="text">The text to insert.</param>
[Experimental]public async Task InsertText(
 string @text) {
var resp = await _target.SendRequest("Input.insertText",
new InsertTextParams {
Text=@text,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class ImeSetCompositionParams {
/// <summary>
/// The text to insert
/// </summary>
[JsonPropertyName("text")]public string Text{get;set;}
/// <summary>
/// selection start
/// </summary>
[JsonPropertyName("selectionStart")]public long SelectionStart{get;set;}
/// <summary>
/// selection end
/// </summary>
[JsonPropertyName("selectionEnd")]public long SelectionEnd{get;set;}
/// <summary>
/// replacement start
/// </summary>
[JsonPropertyName("replacementStart")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? ReplacementStart{get;set;}
/// <summary>
/// replacement end
/// </summary>
[JsonPropertyName("replacementEnd")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? ReplacementEnd{get;set;}
}
/// <summary>
/// This method sets the current candidate text for ime.
/// Use imeCommitComposition to commit the final text.
/// Use imeSetComposition with empty string as text to cancel composition.
/// </summary>
/// <param name="text">The text to insert</param>
/// <param name="selectionStart">selection start</param>
/// <param name="selectionEnd">selection end</param>
/// <param name="replacementStart">replacement start</param>
/// <param name="replacementEnd">replacement end</param>
[Experimental]public async Task ImeSetComposition(
 string @text,long @selectionStart,long @selectionEnd,long? @replacementStart=default,long? @replacementEnd=default) {
var resp = await _target.SendRequest("Input.imeSetComposition",
new ImeSetCompositionParams {
Text=@text,SelectionStart=@selectionStart,SelectionEnd=@selectionEnd,ReplacementStart=@replacementStart,ReplacementEnd=@replacementEnd,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class DispatchMouseEventParams {
/// <summary>
/// Type of the mouse event.
/// </summary>
[JsonConverter(typeof(StringEnumConverter))] public enum TypeEnum {
[EnumMember(Value = "mousePressed")] MousePressed,
[EnumMember(Value = "mouseReleased")] MouseReleased,
[EnumMember(Value = "mouseMoved")] MouseMoved,
[EnumMember(Value = "mouseWheel")] MouseWheel,
}
[JsonPropertyName("type")]public TypeEnum Type{get;set;}
/// <summary>
/// X coordinate of the event relative to the main frame's viewport in CSS pixels.
/// </summary>
[JsonPropertyName("x")]public double X{get;set;}
/// <summary>
/// Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
/// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
/// </summary>
[JsonPropertyName("y")]public double Y{get;set;}
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
[JsonPropertyName("modifiers")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Modifiers{get;set;}
/// <summary>
/// Time at which the event occurred.
/// </summary>
[JsonPropertyName("timestamp")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public Input.TimeSinceEpoch? Timestamp{get;set;}
/// <summary>
/// Mouse button (default: "none").
/// </summary>
[JsonPropertyName("button")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public Input.MouseButton? Button{get;set;}
/// <summary>
/// A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
/// Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
/// </summary>
[JsonPropertyName("buttons")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Buttons{get;set;}
/// <summary>
/// Number of times the mouse button was clicked (default: 0).
/// </summary>
[JsonPropertyName("clickCount")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? ClickCount{get;set;}
/// <summary>
/// The normalized pressure, which has a range of [0,1] (default: 0).
/// </summary>
[Experimental][JsonPropertyName("force")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? Force{get;set;}
/// <summary>
/// The normalized tangential pressure, which has a range of [-1,1] (default: 0).
/// </summary>
[Experimental][JsonPropertyName("tangentialPressure")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? TangentialPressure{get;set;}
/// <summary>
/// The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
/// </summary>
[Experimental][JsonPropertyName("tiltX")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? TiltX{get;set;}
/// <summary>
/// The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
/// </summary>
[Experimental][JsonPropertyName("tiltY")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? TiltY{get;set;}
/// <summary>
/// The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
/// </summary>
[Experimental][JsonPropertyName("twist")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Twist{get;set;}
/// <summary>
/// X delta in CSS pixels for mouse wheel event (default: 0).
/// </summary>
[JsonPropertyName("deltaX")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? DeltaX{get;set;}
/// <summary>
/// Y delta in CSS pixels for mouse wheel event (default: 0).
/// </summary>
[JsonPropertyName("deltaY")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? DeltaY{get;set;}
/// <summary>
/// Pointer type (default: "mouse").
/// </summary>
[JsonConverter(typeof(StringEnumConverter))] public enum PointerTypeEnum {
[EnumMember(Value = "mouse")] Mouse,
[EnumMember(Value = "pen")] Pen,
}
[JsonPropertyName("pointerType")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public PointerTypeEnum? PointerType{get;set;}
}
/// <summary>
/// Dispatches a mouse event to the page.
/// </summary>
/// <param name="type">Type of the mouse event.</param>
/// <param name="x">X coordinate of the event relative to the main frame's viewport in CSS pixels.</param>
/// <param name="y">Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
/// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.</param>
/// <param name="modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).</param>
/// <param name="timestamp">Time at which the event occurred.</param>
/// <param name="button">Mouse button (default: "none").</param>
/// <param name="buttons">A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
/// Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.</param>
/// <param name="clickCount">Number of times the mouse button was clicked (default: 0).</param>
/// <param name="force">EXPERIMENTAL The normalized pressure, which has a range of [0,1] (default: 0).</param>
/// <param name="tangentialPressure">EXPERIMENTAL The normalized tangential pressure, which has a range of [-1,1] (default: 0).</param>
/// <param name="tiltX">EXPERIMENTAL The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).</param>
/// <param name="tiltY">EXPERIMENTAL The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).</param>
/// <param name="twist">EXPERIMENTAL The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).</param>
/// <param name="deltaX">X delta in CSS pixels for mouse wheel event (default: 0).</param>
/// <param name="deltaY">Y delta in CSS pixels for mouse wheel event (default: 0).</param>
/// <param name="pointerType">Pointer type (default: "mouse").</param>
public async Task DispatchMouseEvent(
 DispatchMouseEventParams.TypeEnum @type,double @x,double @y,long? @modifiers=default,Input.TimeSinceEpoch? @timestamp=default,Input.MouseButton? @button=default,long? @buttons=default,long? @clickCount=default,double? @force=default,double? @tangentialPressure=default,long? @tiltX=default,long? @tiltY=default,long? @twist=default,double? @deltaX=default,double? @deltaY=default,DispatchMouseEventParams.PointerTypeEnum? @pointerType=default) {
var resp = await _target.SendRequest("Input.dispatchMouseEvent",
new DispatchMouseEventParams {
Type=@type,X=@x,Y=@y,Modifiers=@modifiers,Timestamp=@timestamp,Button=@button,Buttons=@buttons,ClickCount=@clickCount,Force=@force,TangentialPressure=@tangentialPressure,TiltX=@tiltX,TiltY=@tiltY,Twist=@twist,DeltaX=@deltaX,DeltaY=@deltaY,PointerType=@pointerType,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class DispatchTouchEventParams {
/// <summary>
/// Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
/// TouchStart and TouchMove must contains at least one.
/// </summary>
[JsonConverter(typeof(StringEnumConverter))] public enum TypeEnum {
[EnumMember(Value = "touchStart")] TouchStart,
[EnumMember(Value = "touchEnd")] TouchEnd,
[EnumMember(Value = "touchMove")] TouchMove,
[EnumMember(Value = "touchCancel")] TouchCancel,
}
[JsonPropertyName("type")]public TypeEnum Type{get;set;}
/// <summary>
/// Active touch points on the touch device. One event per any changed point (compared to
/// previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
/// one by one.
/// </summary>
[JsonPropertyName("touchPoints")]public Input.TouchPoint[] TouchPoints{get;set;}
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
[JsonPropertyName("modifiers")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Modifiers{get;set;}
/// <summary>
/// Time at which the event occurred.
/// </summary>
[JsonPropertyName("timestamp")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public Input.TimeSinceEpoch? Timestamp{get;set;}
}
/// <summary>
/// Dispatches a touch event to the page.
/// </summary>
/// <param name="type">Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
/// TouchStart and TouchMove must contains at least one.</param>
/// <param name="touchPoints">Active touch points on the touch device. One event per any changed point (compared to
/// previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
/// one by one.</param>
/// <param name="modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).</param>
/// <param name="timestamp">Time at which the event occurred.</param>
public async Task DispatchTouchEvent(
 DispatchTouchEventParams.TypeEnum @type,Input.TouchPoint[] @touchPoints,long? @modifiers=default,Input.TimeSinceEpoch? @timestamp=default) {
var resp = await _target.SendRequest("Input.dispatchTouchEvent",
new DispatchTouchEventParams {
Type=@type,TouchPoints=@touchPoints,Modifiers=@modifiers,Timestamp=@timestamp,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class EmulateTouchFromMouseEventParams {
/// <summary>
/// Type of the mouse event.
/// </summary>
[JsonConverter(typeof(StringEnumConverter))] public enum TypeEnum {
[EnumMember(Value = "mousePressed")] MousePressed,
[EnumMember(Value = "mouseReleased")] MouseReleased,
[EnumMember(Value = "mouseMoved")] MouseMoved,
[EnumMember(Value = "mouseWheel")] MouseWheel,
}
[JsonPropertyName("type")]public TypeEnum Type{get;set;}
/// <summary>
/// X coordinate of the mouse pointer in DIP.
/// </summary>
[JsonPropertyName("x")]public long X{get;set;}
/// <summary>
/// Y coordinate of the mouse pointer in DIP.
/// </summary>
[JsonPropertyName("y")]public long Y{get;set;}
/// <summary>
/// Mouse button. Only "none", "left", "right" are supported.
/// </summary>
[JsonPropertyName("button")]public Input.MouseButton Button{get;set;}
/// <summary>
/// Time at which the event occurred (default: current time).
/// </summary>
[JsonPropertyName("timestamp")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public Input.TimeSinceEpoch? Timestamp{get;set;}
/// <summary>
/// X delta in DIP for mouse wheel event (default: 0).
/// </summary>
[JsonPropertyName("deltaX")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? DeltaX{get;set;}
/// <summary>
/// Y delta in DIP for mouse wheel event (default: 0).
/// </summary>
[JsonPropertyName("deltaY")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? DeltaY{get;set;}
/// <summary>
/// Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).
/// </summary>
[JsonPropertyName("modifiers")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Modifiers{get;set;}
/// <summary>
/// Number of times the mouse button was clicked (default: 0).
/// </summary>
[JsonPropertyName("clickCount")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? ClickCount{get;set;}
}
/// <summary>
/// Emulates touch event from the mouse event parameters.
/// </summary>
/// <param name="type">Type of the mouse event.</param>
/// <param name="x">X coordinate of the mouse pointer in DIP.</param>
/// <param name="y">Y coordinate of the mouse pointer in DIP.</param>
/// <param name="button">Mouse button. Only "none", "left", "right" are supported.</param>
/// <param name="timestamp">Time at which the event occurred (default: current time).</param>
/// <param name="deltaX">X delta in DIP for mouse wheel event (default: 0).</param>
/// <param name="deltaY">Y delta in DIP for mouse wheel event (default: 0).</param>
/// <param name="modifiers">Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
/// (default: 0).</param>
/// <param name="clickCount">Number of times the mouse button was clicked (default: 0).</param>
[Experimental]public async Task EmulateTouchFromMouseEvent(
 EmulateTouchFromMouseEventParams.TypeEnum @type,long @x,long @y,Input.MouseButton @button,Input.TimeSinceEpoch? @timestamp=default,double? @deltaX=default,double? @deltaY=default,long? @modifiers=default,long? @clickCount=default) {
var resp = await _target.SendRequest("Input.emulateTouchFromMouseEvent",
new EmulateTouchFromMouseEventParams {
Type=@type,X=@x,Y=@y,Button=@button,Timestamp=@timestamp,DeltaX=@deltaX,DeltaY=@deltaY,Modifiers=@modifiers,ClickCount=@clickCount,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class SetIgnoreInputEventsParams {
/// <summary>
/// Ignores input events processing when set to true.
/// </summary>
[JsonPropertyName("ignore")]public bool Ignore{get;set;}
}
/// <summary>
/// Ignores input events (useful while auditing page).
/// </summary>
/// <param name="ignore">Ignores input events processing when set to true.</param>
public async Task SetIgnoreInputEvents(
 bool @ignore) {
var resp = await _target.SendRequest("Input.setIgnoreInputEvents",
new SetIgnoreInputEventsParams {
Ignore=@ignore,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class SetInterceptDragsParams {
[JsonPropertyName("enabled")]public bool Enabled{get;set;}
}
/// <summary>
/// Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
/// Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
/// </summary>
/// <param name="enabled"></param>
[Experimental]public async Task SetInterceptDrags(
 bool @enabled) {
var resp = await _target.SendRequest("Input.setInterceptDrags",
new SetInterceptDragsParams {
Enabled=@enabled,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class SynthesizePinchGestureParams {
/// <summary>
/// X coordinate of the start of the gesture in CSS pixels.
/// </summary>
[JsonPropertyName("x")]public double X{get;set;}
/// <summary>
/// Y coordinate of the start of the gesture in CSS pixels.
/// </summary>
[JsonPropertyName("y")]public double Y{get;set;}
/// <summary>
/// Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
/// </summary>
[JsonPropertyName("scaleFactor")]public double ScaleFactor{get;set;}
/// <summary>
/// Relative pointer speed in pixels per second (default: 800).
/// </summary>
[JsonPropertyName("relativeSpeed")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? RelativeSpeed{get;set;}
/// <summary>
/// Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).
/// </summary>
[JsonPropertyName("gestureSourceType")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public Input.GestureSourceType? GestureSourceType{get;set;}
}
/// <summary>
/// Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
/// </summary>
/// <param name="x">X coordinate of the start of the gesture in CSS pixels.</param>
/// <param name="y">Y coordinate of the start of the gesture in CSS pixels.</param>
/// <param name="scaleFactor">Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).</param>
/// <param name="relativeSpeed">Relative pointer speed in pixels per second (default: 800).</param>
/// <param name="gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).</param>
[Experimental]public async Task SynthesizePinchGesture(
 double @x,double @y,double @scaleFactor,long? @relativeSpeed=default,Input.GestureSourceType? @gestureSourceType=default) {
var resp = await _target.SendRequest("Input.synthesizePinchGesture",
new SynthesizePinchGestureParams {
X=@x,Y=@y,ScaleFactor=@scaleFactor,RelativeSpeed=@relativeSpeed,GestureSourceType=@gestureSourceType,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class SynthesizeScrollGestureParams {
/// <summary>
/// X coordinate of the start of the gesture in CSS pixels.
/// </summary>
[JsonPropertyName("x")]public double X{get;set;}
/// <summary>
/// Y coordinate of the start of the gesture in CSS pixels.
/// </summary>
[JsonPropertyName("y")]public double Y{get;set;}
/// <summary>
/// The distance to scroll along the X axis (positive to scroll left).
/// </summary>
[JsonPropertyName("xDistance")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? XDistance{get;set;}
/// <summary>
/// The distance to scroll along the Y axis (positive to scroll up).
/// </summary>
[JsonPropertyName("yDistance")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? YDistance{get;set;}
/// <summary>
/// The number of additional pixels to scroll back along the X axis, in addition to the given
/// distance.
/// </summary>
[JsonPropertyName("xOverscroll")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? XOverscroll{get;set;}
/// <summary>
/// The number of additional pixels to scroll back along the Y axis, in addition to the given
/// distance.
/// </summary>
[JsonPropertyName("yOverscroll")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public double? YOverscroll{get;set;}
/// <summary>
/// Prevent fling (default: true).
/// </summary>
[JsonPropertyName("preventFling")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public bool? PreventFling{get;set;}
/// <summary>
/// Swipe speed in pixels per second (default: 800).
/// </summary>
[JsonPropertyName("speed")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Speed{get;set;}
/// <summary>
/// Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).
/// </summary>
[JsonPropertyName("gestureSourceType")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public Input.GestureSourceType? GestureSourceType{get;set;}
/// <summary>
/// The number of times to repeat the gesture (default: 0).
/// </summary>
[JsonPropertyName("repeatCount")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? RepeatCount{get;set;}
/// <summary>
/// The number of milliseconds delay between each repeat. (default: 250).
/// </summary>
[JsonPropertyName("repeatDelayMs")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? RepeatDelayMs{get;set;}
/// <summary>
/// The name of the interaction markers to generate, if not empty (default: "").
/// </summary>
[JsonPropertyName("interactionMarkerName")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public string? InteractionMarkerName{get;set;}
}
/// <summary>
/// Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
/// </summary>
/// <param name="x">X coordinate of the start of the gesture in CSS pixels.</param>
/// <param name="y">Y coordinate of the start of the gesture in CSS pixels.</param>
/// <param name="xDistance">The distance to scroll along the X axis (positive to scroll left).</param>
/// <param name="yDistance">The distance to scroll along the Y axis (positive to scroll up).</param>
/// <param name="xOverscroll">The number of additional pixels to scroll back along the X axis, in addition to the given
/// distance.</param>
/// <param name="yOverscroll">The number of additional pixels to scroll back along the Y axis, in addition to the given
/// distance.</param>
/// <param name="preventFling">Prevent fling (default: true).</param>
/// <param name="speed">Swipe speed in pixels per second (default: 800).</param>
/// <param name="gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).</param>
/// <param name="repeatCount">The number of times to repeat the gesture (default: 0).</param>
/// <param name="repeatDelayMs">The number of milliseconds delay between each repeat. (default: 250).</param>
/// <param name="interactionMarkerName">The name of the interaction markers to generate, if not empty (default: "").</param>
[Experimental]public async Task SynthesizeScrollGesture(
 double @x,double @y,double? @xDistance=default,double? @yDistance=default,double? @xOverscroll=default,double? @yOverscroll=default,bool? @preventFling=default,long? @speed=default,Input.GestureSourceType? @gestureSourceType=default,long? @repeatCount=default,long? @repeatDelayMs=default,string? @interactionMarkerName=default) {
var resp = await _target.SendRequest("Input.synthesizeScrollGesture",
new SynthesizeScrollGestureParams {
X=@x,Y=@y,XDistance=@xDistance,YDistance=@yDistance,XOverscroll=@xOverscroll,YOverscroll=@yOverscroll,PreventFling=@preventFling,Speed=@speed,GestureSourceType=@gestureSourceType,RepeatCount=@repeatCount,RepeatDelayMs=@repeatDelayMs,InteractionMarkerName=@interactionMarkerName,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class SynthesizeTapGestureParams {
/// <summary>
/// X coordinate of the start of the gesture in CSS pixels.
/// </summary>
[JsonPropertyName("x")]public double X{get;set;}
/// <summary>
/// Y coordinate of the start of the gesture in CSS pixels.
/// </summary>
[JsonPropertyName("y")]public double Y{get;set;}
/// <summary>
/// Duration between touchdown and touchup events in ms (default: 50).
/// </summary>
[JsonPropertyName("duration")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? Duration{get;set;}
/// <summary>
/// Number of times to perform the tap (e.g. 2 for double tap, default: 1).
/// </summary>
[JsonPropertyName("tapCount")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public long? TapCount{get;set;}
/// <summary>
/// Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).
/// </summary>
[JsonPropertyName("gestureSourceType")][JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
public Input.GestureSourceType? GestureSourceType{get;set;}
}
/// <summary>
/// Synthesizes a tap gesture over a time period by issuing appropriate touch events.
/// </summary>
/// <param name="x">X coordinate of the start of the gesture in CSS pixels.</param>
/// <param name="y">Y coordinate of the start of the gesture in CSS pixels.</param>
/// <param name="duration">Duration between touchdown and touchup events in ms (default: 50).</param>
/// <param name="tapCount">Number of times to perform the tap (e.g. 2 for double tap, default: 1).</param>
/// <param name="gestureSourceType">Which type of input events to be generated (default: 'default', which queries the platform
/// for the preferred input type).</param>
[Experimental]public async Task SynthesizeTapGesture(
 double @x,double @y,long? @duration=default,long? @tapCount=default,Input.GestureSourceType? @gestureSourceType=default) {
var resp = await _target.SendRequest("Input.synthesizeTapGesture",
new SynthesizeTapGestureParams {
X=@x,Y=@y,Duration=@duration,TapCount=@tapCount,GestureSourceType=@gestureSourceType,});
_target.DeserializeResponse<VoidData>(resp);
}
public sealed partial class DragInterceptedParams {
[JsonPropertyName("data")]public Input.DragData Data{get;set;}
}
private Action<DragInterceptedParams>? _onDragIntercepted;
/// <summary>
/// Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
/// restore normal drag and drop behavior.
/// </summary>
[Experimental]public event Action<DragInterceptedParams> OnDragIntercepted {
add => _onDragIntercepted += value; remove => _onDragIntercepted -= value;}
public void DispatchEvent(string method, ArraySegment<byte> data) {
switch (method) {
case "Input.dragIntercepted":
_onDragIntercepted?.Invoke(_target.DeserializeEvent<DragInterceptedParams>(data));
break;
default:
_onUnknownEvent?.Invoke(method, data);
break;
}}
private Action<string, ArraySegment<byte>>? _onUnknownEvent;
public event Action<string, ArraySegment<byte>> OnUnknownEvent {
add => _onUnknownEvent += value; remove => _onUnknownEvent -= value;}
public void DisconnectEvents() {
_onUnknownEvent = null;
_onDragIntercepted = null;
}
}
